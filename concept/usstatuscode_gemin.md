好的，这是对您提供的 **OPC UA 状态码 (`UaStatusCode`)** 详细描述的总结文档。这份文档详细解释了状态码的结构、严重性、位分配以及客户端处理规则。

-----

# 📄 `UaStatusCode`（状态码）详尽文档

## 概述

`UaStatusCode` 是 OPC UA 服务器用于报告操作结果的核心 32 位无符号数值。它提供了客户端程序处理服务结果所需的关键信息。

  * **封装类：** `UaStatusCode` 是底层 `StatusCode` 的 C++ 封装，用于处理内存和提供实用方法（如 `toString()`）。
  * **派生类：** `UaStatus` 派生自 `UaStatusCode`，并增加了对 **诊断信息 (Diagnostic Information)** 的封装，以提供更详细的状态描述。

## 一、 状态码结构与客户端处理原则

### 1\. 结构与组成

`StatusCode` 是一个 32 位无符号整数，分为高 16 位和低 16 位：

  * **高 16 位 (Bits 16-31)：** **主代码/子代码 (SubCode) 和 严重程度 (Severity)**。用于识别特定的错误或条件，是客户端判断操作结果的主要依据。
  * **低 16 位 (Bits 0-15)：** **位标志 (Bit Flags)**。包含额外的信息，如数据质量或结构变化，**但不影响状态码的根本含义**（Good, Bad, Uncertain）。

### 2\. 客户端处理原则 (强制要求)

客户端在处理任何结果时，必须首先检查其关联的 `StatusCode`：

| 严重程度 | 含义 | 处理原则 |
| :--- | :--- | :--- |
| **Good / Success** | 0x00... | **应该使用。** 操作正常完成，结果始终有效。 |
| **Uncertain / Warning** | 0x40... | **谨慎使用。** 操作未按请求方式完全完成，但未完全失败。结果可能在某些情况下无效。 |
| **Bad / Failed** | 0xC0... | **绝不使用。** 操作失败，结果无效。 |

### 3\. 代码定义与扩展

  * OPC UA 规范定义了所有高 16 位代码（`SubCode`），**不允许使用应用程序特定代码扩展**。
  * 应用程序特定的错误或条件信息必须通过 **诊断信息 (`DiagnosticInfo`)** 提供。

## 二、 状态码位分配详解 (32 位)

| 字段 | 位范围 | 描述 |
| :--- | :--- | :--- |
| **Severity** | 30:31 | 状态的严重程度：Good (00)、Bad (11)、Uncertain (01)。 |
| **Reserved** | 29:28 | 保留位，必须为零。 |
| **SubCode** | 16:27 | 状态码的数值部分，用于定义特定的条件（如 `BadInvalidArgument`）。 |
| **StructureChanged** | 15:15 | **结构变化标志**。 |
| **SemanticsChanged** | 14:14 | **语义变化标志**。 |
| **Reserved** | 12:13 | 保留位，必须为零。 |
| **InfoType** | 10:11 | 低位 `InfoBits` 中包含的信息类型。有效选项：`NotUsed` (00) 和 `DataValue` (01)。 |
| **InfoBits** | 0:9 | 额外的限定信息位，其结构取决于 `InfoType` 字段。 |

-----

## 三、 低位标志 (`InfoType` & Bit Flags)

低 16 位提供了关于 **数据质量和元数据状态** 的额外信息。

### 1\. `StructureChanged` 标志 (位 15)

  * **设置条件：** 当与数据值相关联的 **结构数据类型** 发生变化时（例如，结构体定义、`DataType` 属性、`ArrayDimensions` 或 `ValueRank` 属性发生变化）。
  * **客户端行动：** 如果设置，客户端应**重新读取元数据**，否则可能会因序列化格式改变而导致解析失败。
  * **适用场景：** 仅对数据变化通知 (`Notification`) 或历史读取 (`HistoryRead`) 返回的 `StatusCode` 有意义，其他上下文中应为零。

### 2\. `SemanticsChanged` 标志 (位 14)

  * **设置条件：** 当与数据值关联的 **语义元数据** 发生变化时（例如，变量的工程单位 `EngineeringUnits` 属性改变）。
  * **客户端行动：** 如果设置，客户端应**重新读取元数据**，因为元数据变化可能导致应用程序逻辑错误（如计算错误）。
  * **适用场景：** 仅对数据变化通知或历史读取返回的 `StatusCode` 有意义，其他上下文中应为零。

-----

## 四、 `DataValue` 相关的 `InfoBits` 详解 (当 `InfoType` 为 `01` 时)

当 `InfoType` 字段为 `01` 时，低 10 位 (`InfoBits`) 包含以下关于数据质量和历史的特定信息：

| 位范围 | 字段 | 描述 |
| :--- | :--- | :--- |
| **8:9** | **LimitBits** | **数据限制信息**：<br> • **None (00)**：值可自由变化。<br> • **Low (01)**：值在数据源的下限。<br> • **High (10)**：值在数据源的上限。<br> • **Constant (11)**：值是常量，不能改变。 |
| **7:7** | **Overflow** | **溢出标志**：如果设置，表示服务器的监控项队列缓冲区已满，有数据被清除，客户端未收到所有检测到的变化。 |
| **0:4** | **HistorianBits** | **历史数据信息**：仅在历史读取时设置，指示数据的来源和特性：<br> • **Raw (XXX00)**：原始数据值。<br> • **Calculated (XXX01)**：计算得出的值。<br> • **Interpolated (XXX10)**：插值得到的值。<br> • **Partial (XX1XX)**：计算基于不完整时间间隔。<br> • **Extra Data (X1XXX)**：在相同时间戳隐藏了其他数据的原始值。<br> • **Multi Value (1XXXX)**：多个值匹配聚合条件。 |

**下一步我可以为您做些什么？**

  * 您希望我总结一下 OPC UA 中 **数据质量（Quality）** 的概念，以及它与 `StatusCode` 的关系吗？
  * 或者，您想讨论 `UaStatus` 类如何将 `StatusCode` 与 **`DiagnosticInfo`** 结合起来？