
```c
/* tests if a status code is good. */
#define OpcUa_IsGood(xCode) (((xCode) & 0xC0000000) == 0x00000000)
```
这段代码是一个用于 **检查 OPC UA 状态码（`StatusCode`）是否表示“成功”** 的 C 宏定义。

---

## 🔍 `OpcUa_IsGood(xCode)` 宏定义解析

### 1. 核心功能

* **功能：** 测试一个 32 位无符号整数的状态码 (`xCode`) 是否表示一个 **成功（Good）** 的结果。
* **用途：** 在 OPC UA 客户端和服务器代码中，用于验证服务调用是否成功，或者单个数据项（如 Read/Write 服务的返回结果）是否有效。

### 2. OPC UA 状态码结构

OPC UA 的 `StatusCode` 是一个 32 位无符号整数，其结构中最重要的部分是 **最高两位（第 30 位和第 31 位）**，它们定义了状态码的严重程度（Severity）：

| 两位 | 16 进制掩码 (Hex Mask) | 严重程度 | 含义 |
| :--- | :--- | :--- | :--- |
| **00** | `0x00000000` | **Good (成功)** | 操作成功完成，结果有效。 |
| **01** | `0x40000000` | **Uncertain (不确定)** | 操作完成，但数据可能不可靠（例如，数据质量不佳）。 |
| **10** | `0x80000000` | **Reserved (保留)** | 未使用。 |
| **11** | `0xC0000000` | **Bad (失败)** | 操作失败，结果无效。 |

### 3. 宏定义执行逻辑

宏定义 `((xCode) & 0xC0000000) == 0x00000000` 执行以下步骤：

1.  **掩码 (`0xC0000000`)：** 这个 32 位值（二进制是 `1100 0000 ... 0000`）用于创建一个 **位掩码**，专门隔离状态码 `xCode` 的 **最高两位**。
2.  **位与操作 (`&`)：** 将输入的状态码 `xCode` 与掩码 `0xC0000000` 进行 **位与操作**。这个操作会清零除了最高两位之外的所有位，只保留表示严重程度的两位。
    * 例如：如果 `xCode` 是 `0x00123456` (Good)，结果是 `0x00000000`。
    * 如果 `xCode` 是 `0x80123456` (Bad)，结果是 `0x80000000`。
3.  **比较 (`== 0x00000000`)：** 将位与操作的结果与 `0x00000000` 进行比较。
    * **如果结果为 `0x00000000`**，则表示状态码的最高两位是 **`00`**，宏返回 **True**，即状态码是 **Good**。
    * **如果结果非 `0x00000000`**（例如 `0xC0000000` 或 `0x40000000`），宏返回 **False**，即状态码不是 Good。

### 总结

该宏是 OPC UA 状态码处理中的一个基本工具，它通过 **位运算** 快速、高效地确定一个操作或数据的结果是否完全成功且数据质量良好。